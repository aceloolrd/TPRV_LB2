#include <opencv2/opencv.hpp>
#include <omp.h>

using namespace cv;

// Функция для применения сверточного слоя с заданным ядром
Mat applyConvolution(const Mat& inputImage, const Mat& kernel) {
    Mat outputImage = inputImage.clone();
    int kernelRadius = kernel.rows / 2;

#pragma omp parallel for collapse(2) shared(inputImage, outputImage, kernel)
    for (int y = kernelRadius; y < inputImage.rows - kernelRadius; ++y) {
        for (int x = kernelRadius; x < inputImage.cols - kernelRadius; ++x) {
            // Применение свертки в текущем пикселе
            float sum = 0.0f;
            for (int ky = -kernelRadius; ky <= kernelRadius; ++ky) {
                for (int kx = -kernelRadius; kx <= kernelRadius; ++kx) {
                    sum += inputImage.at<uchar>(y + ky, x + kx) * kernel.at<float>(ky + kernelRadius, kx + kernelRadius);
                }
            }

            // Запись результата в выходное изображение
            outputImage.at<uchar>(y, x) = saturate_cast<uchar>(sum);
        }
    }

    return outputImage;
}

int main() {
    // Загрузка изображения с использованием OpenCV
    Mat inputImage = imread("test.png", IMREAD_GRAYSCALE);

    if (inputImage.empty()) {
        std::cerr << "Could not open or find the image!" << std::endl;
        return -1;
    }

    // Задание ядра свертки 3x3 (пример)
    Mat kernel = (Mat_<float>(3, 3) << -1, -1, -1, -1, 8, -1, -1, -1, -1);

    // Применение сверточного слоя
    Mat outputImage = applyConvolution(inputImage, kernel);

    // Вывод результатов
    namedWindow("Input Image", WINDOW_NORMAL);
    namedWindow("Output Image", WINDOW_NORMAL);

    imshow("Input Image", inputImage);
    imshow("Output Image", outputImage);

    waitKey(0);

    return 0;
}
